
    public void run() {
        try {
            while(!stopped) {
                try {
                    select();
                    processAcceptedConnections();
                    processInterestOpsUpdateRequests();
                } catch (RuntimeException e) {
                    LOG.warn("Ignoring unexpected runtime exception", e);
                }

                  catch (Exception e) {
                    LOG.warn("Ignoring unexpected exception", e);
                }
            }

                // Close connections still pending on the selector. Any others
                // with in-flight work, let drain out of the work queue.

            for (SelectionKey key : selector.keys()) {
                NIOServerCnxn cnxn = (NIOServerCnxn) key.attachment();

                if (cnxn.isSelectable()) {
                    cnxn.close(ServerCnxn.DisconnectReason.SERVER_SHUTDOWN);
                }

                cleanupSelectionKey(key);
            }

            SocketChannel accepted;
            while((accepted = acceptedQueue.poll()) != null) {
                fastCloseSock(accepted);
            }

            updateQueue.clear();
        }

        finally {
            closeSelector();
                // This will wake up the accept thread and the other selector
                // threads, and tell the worker thread pool to begin shutdown.
            NIOServerCnxnFactory.this.stop();
            LOG.info("selector thread exited run method");
        }
    }

